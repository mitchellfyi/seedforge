The pedagogical name for what you're describing
There are two key frameworks, and your product sits at their intersection:
1. Constructionism (Seymour Papert, MIT) — the "learning by making" theory. The core premise is that learning happens most powerfully when learners design and build personally meaningful, shareable artifacts and reflect on those creations. The artifact functions as an "object to think with." TeachThought Constructionism clarifies that learning is most powerful when we create and share any kind of artifact, whether that's a new robot, a videogame, a hand-knitted scarf, or a theory of the universe. Educator Innovator Papert's key insight was that expressing ideas makes them tangible and shareable, which in turn sharpens those ideas and helps us communicate with others through our expressions. University of Toronto
2. Project-Based Learning (PBL) — the instructional framework. Students pursue solutions to nontrivial problems by asking and refining questions, debating ideas, making predictions, designing plans, collecting and analyzing data, drawing conclusions, communicating their ideas, and creating artifacts. Wikipedia The key distinction from normal "projects" is that the project is introduced at the beginning of the unit of study, not the end — the project leads into learning, pushing students to learn and practice skills in order to complete it. Tony Vincent, Inc.
What you're building is essentially AI-powered Constructionist PBL — where AI takes the role of the instructor who designs the project, provides scaffolding, and adapts in real-time.

How the structure works (the research-backed flow)
The research gives us a very clear 5-phase structure. The five phases are: Project Planning (determine the cognitive path and content outcomes), Project Launch (introduce the Driving Question and Need to Know list), Project Implementation (engage in learning, analysis, and evaluation), Project Conclusion (create and present the final product), and Project Debrief (reflect on performance and learning). Wegrowteachers
The critical components that make it work:
The Driving Question (DQ) — this is the engine of the whole thing. Best practice is starting with "How might (or can) we…?" instead of "What is…?" and making sure the question can't be answered by a Google search. Wegrowteachers Students need clarity on three things: what they're creating, why they're creating it, and for whom. The driving question creates interest and a feeling of challenge, guides the project work so everything students do helps them answer it, and helps them answer "why are we doing this?" Smore Newsletters
The Need to Know list — once you have a DQ, students unpack what they need to learn to answer it. This is where the learning content emerges organically from the project rather than being imposed top-down.
Tangible artifact — when artifacts are made public, they motivate students and present opportunities for feedback. The public audience principle emphasises that project work should be authentic and connected to the real world. MDRC
The Bloom's Taxonomy flip — this is a crucial insight. PBL flips Bloom's Taxonomy — the Project Launch introduces the Create level (via the product/DQ), which motivates students to master the lower levels of Remember, Understand, Apply, Analyze, and Evaluate in order to complete the high-level creation task. Wegrowteachers Normally education goes bottom-up (learn facts → apply them). PBL goes top-down (here's what you're making → now figure out what you need to know).

The scaffolding model (how the UX should feel)
This is where Vygotsky's Zone of Proximal Development (ZPD) comes in — the sweet spot between what a learner can do alone and what's too hard even with help.
The ZPD identifies three zones: what's easy to learn (boredom territory), the learning zone where you can succeed with support, and what's too difficult (frustration territory). When content is too simple the user experiences boredom, when too difficult, anxiety. Odette Jansen
The UX principle that flows from this: scaffolding — temporary, adjustable support that comes in forms like breaking tasks into manageable steps, providing prompts, asking guiding questions, or offering tools that simplify complex tasks. The key aspect is that scaffolding is not permanent — it gradually decreases as learners gain skills and confidence. Coursebox AI
For a digital product, the scaffolding research from games design is directly applicable: scaffolding in games and education are very similar — in education there's a coach or teacher, whereas in games it's the system that gives instructions and guides the player. When designing digital products you can take learnings from both. Medium
And there's a research finding that's often overlooked: a common assumption is that when you provide authentic, problem-based experiences, students will automatically be engaged — evidence indicates this is often not the case. PubMed Central Scaffolds need to support both motivation and cognition, not just cognitive support.

What the UX structure should look like for your product
Synthesising the research, here's the structural flow mapped to a product:
Step 1 — Discovery & DQ generation. User tells the AI what they want to learn or get better at. AI generates a compelling Driving Question and a personalised project with a tangible artifact outcome. "I want to learn graphic design for my Cricut" → "Design a set of custom seasonal greeting cards that teach you colour theory, typography, and vector editing — and you'll have ready-to-cut SVG files at the end."
Step 2 — Need to Know unpacking. AI breaks the project into a visible map of skills/knowledge needed. User can see what they'll learn and why each piece matters for the project. This creates the pull motivation.
Step 3 — Scaffolded building. The user works through the project in stages. AI provides just-in-time teaching (mini-lessons, examples, explanations) at each stage — not upfront lectures. Scaffolding fades as competence grows. The AI acts as the "More Knowledgeable Other" from Vygotsky's framework.
Step 4 — Artifact completion. User finishes a real, shareable thing. A PDF field guide, a set of SVG files, a portfolio piece, a presentation, a recipe collection, a zine — whatever the project demanded.
Step 5 — Reflection & showcase. User reviews what they learned, the AI surfaces their progression, and the artifact can be shared publicly (which the research shows massively increases motivation and quality).
The iterative version from AGL (Artifact-Generated Learning) research adds another layer: students create first drafts of their learning artifacts, receive formative assessment, and improve their work during a second or third iteration. PubMed Central So the product should build in revision cycles — draft → feedback → improve — not just one-shot creation.

Key UX principles from the research
The research consistently points to several non-negotiable UX elements: learner agency (choice over what to make and how), authenticity (projects feel real, not school-like), visible progress (the artifact growing in front of you is the progress bar), just-in-time teaching (not front-loaded lectures), and public output (something worth sharing).
The cohesive theme tying this together could be something like "Make something real, learn along the way" — or to borrow from Papert's language, the product is a digital workshop where every project you build is an "object to think with."

Six core systems that map to the PBL research: a Learner Model (persistent skill graph + ZPD calibration), a Project Engine (generates personalised projects with Driving Questions), a Scaffolding Engine (just-in-time teaching that fades as you improve), an Artifact Workspace (adaptive tools that change based on what you're building), an Assessment System (evaluates the artifact, not quizzes), and a Portfolio/Showcase (public gallery + skill progression).
The workspace is a split-pane interface: Build Pane (where you make the thing), Learn Pane (where teaching appears when needed), and Progress Rail (step sequence showing the artifact growing). The artifact itself is the progress bar.
The build order starts pragmatic: Phase 1 (4-6 weeks) is Writer workspace only — prove that someone can say "I want to learn about Victorian architecture" and walk out 45 minutes later with a beautiful guide they made and skills they gained. Phase 2 adds Canvas mode (visual/Cricut artifacts) and persistent learning. Phase 3 adds Code, Slides, Data modes and community.
The moat compounds across learner models, skill taxonomy, project library, and community artifacts — all getting richer with every user interaction.

read product-blueprint.docx

What the product actually needs, layer by layer:
The core experience is: you talk to AI → it generates a project → breaks it into steps → you work through them with AI coaching → you make artifacts → you get rewarded → you get reminded to come back. That's essentially a chat interface bolted to a gamified task system with notifications.
No single open-source project does all of this. But the good news is you don't need one — you need a smart combination.

The Chat SDK (chat-sdk.dev) covers the hardest part to build from scratch. It supports custom artifacts for building specialised components, from document creation to interactive tools, and in-browser code execution with WASM and pyodide without requiring a discrete sandbox setup. Vercel It's a full-featured, hackable Next.js AI chatbot built with the AI SDK that supports multiple AI models through a unified interface. GitHub It already has: streaming AI chat, artifact creation and rendering, tool use, auth, database persistence, file uploads, and theming. That's your Build Pane + Learn Pane + AI coaching in one package.
What Chat SDK doesn't have: task/step management, gamification, progress tracking, notifications, assessment logic, or portfolio. Those need to be layered on.

Habitica is the gold standard for gamified task management and it's fully open source. It's an open-source habit-building program that treats your life like a role-playing game — level up as you succeed, lose HP as you fail, earn gold to buy weapons and armour. GitHub It can be self-hosted with Docker, using a Node.js server, Vue.js client, and MongoDB. GitHub It has XP, levels, streaks, reminders, daily tasks, parties, challenges — basically every gamification pattern you described. The self-hosted fork even gives every user an automatic subscription on registration and the first registered user gets admin rights GitHub.
The problem with Habitica as a base: it's a massive legacy codebase (Vue.js + MongoDB + years of RPG-specific code). Forking it and ripping out the fantasy RPG layer to replace it with a learning platform would be more work than building the gamification features from scratch in your own stack. Its value is as a pattern library — study how they implement XP, levelling, streaks, and reminders, then replicate those patterns in your Next.js app.

Plane (the open-source Jira alternative) is interesting because it has pages with AI capabilities and a rich text editor, plus the ability to format text, insert images, add hyperlinks, and convert notes into actionable items GitHub. It has task tracking, cycles, modules, and analytics. It's built with Next.js frontend and Django backend, using PostgreSQL and Redis. Plane
The problem with Plane as a base: it's a team project management tool. The mental model is wrong — it's built for engineering teams managing sprints, not individuals learning by building. You'd spend more time stripping out enterprise PM features than you'd save.

My actual recommendation — the pragmatic stack:
Start with Chat SDK as your foundation. It gives you the conversational AI, artifact creation, streaming, auth, and database layer in Next.js — the hardest 40% of the product. Then build three custom layers on top:
Layer 1: Project & Step Engine. A custom data model (in the same Postgres the Chat SDK already uses) for: projects, steps within projects, step status, skill tags, and learner profiles. The AI generates these as structured data via tool calls within the chat. Each step is essentially a "task" but with pedagogical metadata (teaching objective, assessment criteria, scaffolding level). This isn't complex to build — it's basically a CRUD layer with a step-sequence UI.
Layer 2: Gamification. XP, levels, streaks, and progress visualisation. Borrow the patterns from Habitica but build them natively in React. There are lightweight open-source libraries for this. The key mechanics: XP awarded on step completion (with bonus for quality assessed by AI), level thresholds, streak tracking (consecutive days with progress), and a visual skill tree/graph. This is probably 2-3 weeks of frontend work plus a simple database schema.
Layer 3: Notifications/Reminders. Use Novu — it's an open-source notification infrastructure that turns multi-channel delivery into a single Inbox component, built for developers Novu. It handles email, push, SMS, and in-app notifications with templates, scheduling, and user preferences. You'd set up workflows like: "If user hasn't made progress in 24 hours, send a nudge. If streak is about to break, send an urgent reminder. If a step was completed, send congratulations." Six lines of code to add the inbox component, and their workflow builder handles the Duolingo-style nudging.

So the architecture becomes:
Chat SDK (Next.js) as the shell — handling AI chat, artifacts, auth, and the core UI. Custom project/step/learner data model in Postgres. Custom gamification layer in React (XP, levels, streaks, skill graph). Novu for notifications and reminders. The AI itself (Claude/GPT) does the heavy lifting: project generation, scaffolding, step assessment, and feedback — all via structured tool calls within the chat.
This gets you to that Phase 1 POC (Writer workspace, one project type, functional gamification) in roughly 4-6 weeks without reinventing anything. The Chat SDK's artifact system becomes your workspace. The chat becomes your Learn Pane. The custom step UI becomes your Progress Rail. And Novu keeps people coming back.
The honest truth is that no existing platform maps cleanly to "AI-powered constructionist learning with gamification." But combining Chat SDK + custom learning layer + Novu gets you 70% of the infrastructure for free, and the remaining 30% is the learning-specific logic that's your actual product differentiation anyway.

